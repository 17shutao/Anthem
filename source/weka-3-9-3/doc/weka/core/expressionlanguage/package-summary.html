<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_112) on Tue Sep 04 15:38:32 NZST 2018 -->
<title>weka.core.expressionlanguage</title>
<meta name="date" content="2018-09-04">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="weka.core.expressionlanguage";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../weka/core/converters/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../weka/core/expressionlanguage/common/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?weka/core/expressionlanguage/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<div class="header">
<h1 title="Package" class="title">Package&nbsp;weka.core.expressionlanguage</h1>
<div class="docSummary">
<div class="block">Package for a framework for simple, flexible and performant expression
 languages</div>
</div>
<p>See:&nbsp;<a href="#package.description">Description</a></p>
</div>
<div class="contentContainer"><a name="package.description">
<!--   -->
</a>
<h2 title="Package weka.core.expressionlanguage Description">Package weka.core.expressionlanguage Description</h2>
<div class="block">Package for a framework for simple, flexible and performant expression
 languages</p>
 
 <h1>Introduction & Overview</h1>
 
 The <a href="../../../weka/core/expressionlanguage/package-summary.html"><code>weka.core.expressionlanguage</code></a> package provides functionality to
 easily create simple languages.</p>
 
 It does so through creating an AST (abstract syntax tree) that can then be
 evaluated.</p>
 
 At the heart of the AST is the <a href="../../../weka/core/expressionlanguage/core/Node.html" title="interface in weka.core.expressionlanguage.core"><code>Node</code></a>
 interface. It's an empty interface to mark types to be an AST node.</br>
 Thus there are no real constraints on AST nodes so that they have as much
 freedom as possible to reflect abstractions of programs.</p>
 
 To give a common base to build upon the <a href="../../../weka/core/expressionlanguage/common/Primitives.html" title="class in weka.core.expressionlanguage.common"><code>Primitives</code></a>
 class provides the subinterfaces for the primitive boolean 
 (<a href="../../../weka/core/expressionlanguage/common/Primitives.BooleanExpression.html" title="interface in weka.core.expressionlanguage.common"><code>Primitives.BooleanExpression</code></a>),
 double (<a href="../../../weka/core/expressionlanguage/common/Primitives.DoubleExpression.html" title="interface in weka.core.expressionlanguage.common"><code>Primitives.DoubleExpression</code></a>)
 and String (<a href="../../../weka/core/expressionlanguage/common/Primitives.StringExpression.html" title="interface in weka.core.expressionlanguage.common"><code>Primitives.StringExpression</code></a>)
 types.</br>
 It furthermore provides implementations of constants and variables of those
 types.</p>
 
 Most extensibility is achieved through adding macros to a language. Macros
 allow for powerful meta-programming since they directly work with AST nodes.
 </br>
 The <a href="../../../weka/core/expressionlanguage/core/Macro.html" title="interface in weka.core.expressionlanguage.core"><code>Macro</code></a> interface defines what a
 macro looks like.</p>
 
 Variable and macro lookup is done through 
 <a href="../../../weka/core/expressionlanguage/core/VariableDeclarations.html" title="interface in weka.core.expressionlanguage.core"><code>VariableDeclarations</code></a> and
 <a href="../../../weka/core/expressionlanguage/core/MacroDeclarations.html" title="interface in weka.core.expressionlanguage.core"><code>MacroDeclarations</code></a> resp. Furthermore,
 both can be combined through 
 <a href="../../../weka/core/expressionlanguage/common/VariableDeclarationsCompositor.html" title="class in weka.core.expressionlanguage.common"><code>VariableDeclarationsCompositor</code></a>
 and <a href="../../../weka/core/expressionlanguage/common/MacroDeclarationsCompositor.html" title="class in weka.core.expressionlanguage.common"><code>MacroDeclarationsCompositor</code></a>
 resp.</br>
 This really allows to add built-in variables and powerful built-in functions
 to a language.</p>
 
 Useful implementations are:</br>
 <ul>
 <li><a href="../../../weka/core/expressionlanguage/common/SimpleVariableDeclarations.html" title="class in weka.core.expressionlanguage.common"><code>SimpleVariableDeclarations</code></a></li>
 <li><a href="../../../weka/core/expressionlanguage/common/MathFunctions.html" title="class in weka.core.expressionlanguage.common"><code>MathFunctions</code></a></li>
 <li><a href="../../../weka/core/expressionlanguage/common/IfElseMacro.html" title="class in weka.core.expressionlanguage.common"><code>IfElseMacro</code></a></li>
 <li><a href="../../../weka/core/expressionlanguage/common/JavaMacro.html" title="class in weka.core.expressionlanguage.common"><code>JavaMacro</code></a></li>
 <li><a href="../../../weka/core/expressionlanguage/common/NoVariables.html" title="class in weka.core.expressionlanguage.common"><code>NoVariables</code></a></li>
 <li><a href="../../../weka/core/expressionlanguage/common/NoMacros.html" title="class in weka.core.expressionlanguage.common"><code>NoMacros</code></a></li>
 <li><a href="../../../weka/core/expressionlanguage/weka/InstancesHelper.html" title="class in weka.core.expressionlanguage.weka"><code>InstancesHelper</code></a></li>
 <li><a href="../../../weka/core/expressionlanguage/weka/StatsHelper.html" title="class in weka.core.expressionlanguage.weka"><code>StatsHelper</code></a></li>
 </ul>
 
 The described framework doesn't touch the syntax of a language so far. The
 syntax is seen as a separate element of a language.</br>
 If a program is given in a textual representation (e.g. "A + sqrt(2.0)" is a
 program in a textual representation), this textual representation declares
 how the AST looks like. That's why the parser's job is to build the AST.</br>
 There is a parser in the <a href="../../../weka/core/expressionlanguage/parser/package-summary.html"><code>weka.core.expressionlanguage.parser</code></a> package.</br>
 However the framework allows for other means to construct an AST if needed.</p>
 
 Built-in operators like (+, -, *, / etc) are a special case, since they can
 be seen as macros, however they are strongly connected to the parser too.</br>
 To separate the parser and these special macros there  is the
 <a href="../../../weka/core/expressionlanguage/common/Operators.html" title="class in weka.core.expressionlanguage.common"><code>Operators</code></a> class which can be used
 by the parser to delegate operator semantics elsewhere.
 
 <h2>A word on parsers</h2>
 
 Currently the parser is generated through the CUP parser generator and jflex
 lexer generator. While parser generators are powerful tools they suffer from
 some unfortunate drawbacks:</p>
 <ul>
 <li>The parsers are generated. So there is an additional indirection between
 the grammar file (used for parser generation) and the generated code.</li>
 <li>The grammar files usually have their own syntax which may be quite
 different from the programming language otherwise used in a project.</li>
 <li>In more complex grammars it's easy to introduce ambiguities and unwanted
 valid syntax.</li>
 </ul>
 It's for these reasons why the parser is kept as simple as possible and with
 as much functionality delegated elsewhere as possible.
 
 <h2>Summary</h2>
 
 A flexible AST structure is given by the
 <a href="../../../weka/core/expressionlanguage/core/Node.html" title="interface in weka.core.expressionlanguage.core"><code>Node</code></a> interface. The
 <a href="../../../weka/core/expressionlanguage/core/Macro.html" title="interface in weka.core.expressionlanguage.core"><code>Macro</code></a> interface allows for powerful
 meta-programming which is an important part of the extensibility features. The
 <a href="../../../weka/core/expressionlanguage/common/Primitives.html" title="class in weka.core.expressionlanguage.common"><code>Primitives</code></a> class gives a good
 basis for the primitive boolean, double & String types.</br>
 The parser is responsible for building up the AST structure. It delegates
 operator semantics to <a href="../../../weka/core/expressionlanguage/common/Operators.html" title="class in weka.core.expressionlanguage.common"><code>Operators</code></a>.
 Symbol lookup is done through the
 <a href="../../../weka/core/expressionlanguage/core/VariableDeclarations.html" title="interface in weka.core.expressionlanguage.core"><code>VariableDeclarations</code></a> and
 <a href="../../../weka/core/expressionlanguage/core/MacroDeclarations.html" title="interface in weka.core.expressionlanguage.core"><code>MacroDeclarations</code></a> interfaces which
 can be combined with the
 <a href="../../../weka/core/expressionlanguage/common/VariableDeclarationsCompositor.html" title="class in weka.core.expressionlanguage.common"><code>VariableDeclarationsCompositor</code></a>
 and <a href="../../../weka/core/expressionlanguage/common/MacroDeclarationsCompositor.html" title="class in weka.core.expressionlanguage.common"><code>MacroDeclarationsCompositor</code></a>
 classes resp.</p>
 
 <h1>Usage</h1>
 
 With the described framework it's possible to create languages in a declarative
 way. Examples can be found in
 <a href="../../../weka/filters/unsupervised/attribute/MathExpression.html" title="class in weka.filters.unsupervised.attribute"><code>MathExpression</code></a>,
 <a href="../../../weka/filters/unsupervised/attribute/AddExpression.html" title="class in weka.filters.unsupervised.attribute"><code>AddExpression</code></a> and
 <a href="../../../weka/filters/unsupervised/instance/SubsetByExpression.html" title="class in weka.filters.unsupervised.instance"><code>SubsetByExpression</code></a>.</p>
 
 A commonly used language is:<p>
 
 <code><pre>
 // exposes instance values and 'ismissing' macro
 InstancesHelper instancesHelper = new InstancesHelper(dataset);
 
 // creates the AST
 Node node = Parser.parse(
   // expression
   expression, // textual representation of the program
   // variables
   instancesHelper,
   // macros
   new MacroDeclarationsCompositor(
     instancesHelper,
     new MathFunctions(),
     new IfElseMacro(),
     new JavaMacro()
   )
 );

 // type checking is neccessary, but allows for greater flexibility
 if (!(node instanceof DoubleExpression))
   throw new Exception("Expression must be of boolean type!");
    
 DoubleExpression program = (DoubleExpression) node;
 </pre></code>
 
 <h1>History</h1>
 
 Previously there were three very similar languages in the
 <code>weka.core.mathematicalexpression</code> package,
 <code>weka.core.AttributeExpression</code> class and the
 <code>weka.filters.unsupervised.instance.subsetbyexpression</code> package.</br>
 Due to their similarities it was decided to unify them into one expressionlanguage.
 However backwards compatibility was an important goal, that's why there are
 some quite redundant parts in the language (e.g. both 'and' and '&' are operators
 for logical and).</div>
<dl>
<dt><span class="simpleTagLabel">Version:</span></dt>
<dd>$Revision: 1000 $</dd>
<dt><span class="simpleTagLabel">Author:</span></dt>
<dd>Benjamin Weber ( benweber at student dot ethz dot ch )</dd>
</dl>
</div>
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li class="navBarCell1Rev">Package</li>
<li>Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../weka/core/converters/package-summary.html">Prev&nbsp;Package</a></li>
<li><a href="../../../weka/core/expressionlanguage/common/package-summary.html">Next&nbsp;Package</a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?weka/core/expressionlanguage/package-summary.html" target="_top">Frames</a></li>
<li><a href="package-summary.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
